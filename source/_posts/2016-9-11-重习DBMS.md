---
title: 重习DBMS
date: 2016-09-11 22:37:20
tags: 数据库
mathjax: true
---

大二的时候学习数据库系统，用的教材是《数据库管理系统 原理与设计》(作者：Raghu Ramakrishnan、Johannes Gehrke)。一开始翻中文版，内容真的是一团糟，后来实在看不下去，换回英文版，虽然效果好了一些，但总体看下来，很多细节处依然不明所以，结果导致数据库一直是我的短板，之后的面试多次被坑。因此，趁现在大四时间较充裕，准备重新学习一遍数据库，教材采用Elmasri Navathe的《Fundamentals of Database Systems》。这本书的英文版和中文版都很不错，相见恨晚~囧~

### Chapter 1 数据库与数据库用户

#### 数据库方法的特征

相比传统的文件处理系统，DBMS具备自己的特性：

1. 自描述性

   传统的文件处理中，数据的定义一般是程序的一部分，这种方法使得文件处理程序无法通用。DBMS则存储了全部所示文件的定义，相当于统一了一种文件的表示协议，使得DBMS的描述性可以更加通用。

2. 数据与程序分离

   传统的文件处理方式中，由于数据格式和程序耦合在一起，一旦文件格式发生改变，程序就要改动。DBMS将数据文件结构和程序分离，用户只需要改变系统目录的记录描述，程序便可以访问新的文件结构。这种特征称为**程序－操作独立性**。

3. 支持数据的多视图

   可以根据不同的需求输出不同的数据查询结果。

4. 数据共享和多用户事务处理

   一个**事务**包含一个或多个数据库访问的执行程序或进程。DBMS可以**并发**执行事务，同时还要保证**隔离性**和**原子性**

#### DBMS的优势

1. DBMS可以控制冗余，保证查询的高效率性（将数据放在一起防止搜索多个文件等）和一致性（保证同一记录的修改可以作用到所有表上）
2. 限制非授权的访问
3. 为程序对象提供持久性存储
4. 提供高效率查询处理的存储结构，通过**索引**和**缓冲**实现高效率查询，同时**查询处理与优化**模块会优化查询语句，选择最佳查询方案
5. 提供备份与恢复
6. 提供多用户界面
7. 表示数据间复杂联系
8. 确保完整性约束

#### DBMS的体系结构

下图摘自《数据库管理系统 原理与设计》

 ![DBMS体系结构](/images/2016-9-11/屏幕快照 2016-09-10 下午10.34.53.png)

<br\>

### Chapter 13 磁盘存储、基本文件结构和散列

#### 存储层次和存储设备

1. 存储层次按照访问速度从高到低分为：RAM(高速缓存)—DRAM(主存)—CD-ROM—磁盘—磁带

   通常，磁盘和二级存储设备成为**非易失性存储器**，而主存成为**易失性存储器**。

#### 二级存储设备

主要包括磁盘设备的硬件描述（包括一些基本概念：寻道时间、旋转延迟、块传输时间等）、磁带存储设备等，由于太过底层，暂时略过不谈。

#### 块缓冲

所谓块缓冲，是指：CPU可以在主存中分几个缓冲区，当CPU在其中一个缓冲区处理数据时，磁盘控制器可以继续向其他缓冲区填充数据，这样，CPU在处理其他缓冲区的数据时就省去了磁盘读取时间。块缓冲能够实现的根本原因：磁盘I/O和cpu运作是分开的。

下图体现了一种称为**双缓冲技术**的工作原理（所谓双缓冲，就是缓冲区的个数为2） ![屏幕快照 2016-09-11 下午11.45.26](/Users/xyz/GitCode/jermmy.github.io/source/images/2016-9-11/屏幕快照 2016-09-11 下午11.45.26.png)

#### 文件记录

1. 数据通常以**记录**的形式存储。例如：一个EMPLOYEE记录表示一个雇员实体，记录中包含一些属性Name、Birth_data、Salary等，那么一条EMPLOYEE**记录**通常包含这些属性的值，而EMPLOYEE记录本身则构成了一个**记录类型**（记录了属性名和属性类型）。

   媒体等二进制大对象(Binary Large Object，BLOB)通常单独存储在磁盘块的池中，记录中要包含一个指向BLOB的指针。

2. **文件**是记录的序列。如果文件中所有记录长度均相等，则称这个文件由**定长记录**组成，否则由**变长记录**组成。

   文件之所以会有变长记录，通常有以下几点原因：

   + 文件记录中有**变长字段**，例如：EMPLOYEE表中Name是变长的，或者存在**重复字段**（数组？）。
   + 存在**可选字段**。
   + 包含了不同类型的记录。例如：EMPLOYEE表结束后，紧接着STUDENT表。

3. 由于块是磁盘和主存之间数据传输的单位，所以必须把文件记录分配到块磁盘块中。一个磁盘块可能包含多条文件记录，但有些文件记录太长，导致一个块放不下，于是出现了**跨块记录**。与之对应的是**非跨块记录**。

4. 在磁盘上分配文件块的方式有多种。包括连续分配(有助于双缓冲技术快速读取文件，但扩展文件比较困难)、链接分配、簇(结合前面两种方法)以及索引分配。

5. **文件首部**（或文件描述符）包含了系统程序存取文件记录所需要的文件信息（位置，记录格式等）

#### 文件操作

通常分为**检索**和**更新**。

#### 无序记录文件

无序组织是最简单、最基本的一类组织，记录按其插入顺序存放在文件中，因此新记录会插在文件末尾。这种组织方式称为**堆**或**堆积文件**。

#### 排序记录文件（排序文件）

1. 可以根据记录某个字段的值对磁盘上的文件记录进行物理排序。排序所基于的字段称为**排序字段**。这种文件被称为有序文件或顺序文件。如果排序字段是**码字段**，那么该字段也称为**排序码**。
2. 排序文件相对于无序文件，具有更快的检索速度，尤其是当使用二分查找的时候。但二分查找对磁盘文件并不常用，通常是将磁盘读入内存块后进行二分检索。这样，假设有b个块，二分查找一般只需要存取$$log\_{2}(b)$$块，而线性查找（对于无序文件而言）平均需要存取b/2块才能找到记录。
3. 如果基于其他**非排序字段**值对记录进行查找或存取，排序不会提供任何优势，此时能做的只有线性搜索。如果想提高效率，只能基于其他非排序字段对文件重新排序并创建副本。
4. 对于有序文件来说，**插入**和**删除**也是代价很高的操作。因为记录要保持物理有序，若要插入一个记录，平均需要移动文件的一半记录来腾出新的空间。**删除**操作可以通过删除标志和周期性重组的方法缓解上述问题。而对于**插入**操作，一种小技巧是为新记录预留空间，当然一旦预留空间用完，同样会遇到问题。因此，行之有效的方法是创建一个**临时无序文件**（或**称为溢出文件**）。利用这种技术，新记录并非插在主文件中，而是添加到**溢出文件**末尾，并通过周期性重组将**溢出文件**和原来的**主文件**合并。
5. 数据库中很少使用排序文件，除非使用一种称为**主索引**的额外存取路径，这将导致出现**索引－顺序文件**。如果排序属性不是一个码，则该文件被称为**聚簇文件**。

#### 散列技术

1. **散列文件**是一种可以根据特定搜索条件进行快速记录存取的文件组织。搜索条件必须是对单个字段的相等比较条件，这个字段称为**散列字段**。散列的思想是：提供一个**散列函数**，将该函数应用于记录的散列字段值，并得出存放该记录的磁盘块地址。

2. 散列分类：内部散列、外部散列（分为静态和动态两种）

3. **内部散列**：指的就是内存中的数据散列，与数据结构基本一致。记住一下解决冲突常用的算法：**开放寻址法**、**链接法**、**多散列法**。

4. **静态散列**：在对磁盘文件的静态散列中，目标地址空间被分为多个**桶**（就是文件被分为多份），每个桶存放多个记录。桶既可以是一个磁盘块，也可以是连续块的簇。散列函数将**散列码**映射成一个桶号，在文件首部中维护一个表，这个表再将桶号转换为相应的磁盘块地址。

   ![屏幕快照 2016-09-13 上午12.23.00](/Users/xyz/GitCode/jermmy.github.io/source/images/2016-9-11/屏幕快照 2016-09-13 上午12.23.00.png)

   尽管桶可以存放更多记录，但总有填满的时候，这个时候使用一个溢出指针来维护一个**溢出链表**（链表法变种）。

   使用这种外部散列法时，如果要根据**非散列字段**检索记录，代价跟顺序查找一样大。

   如果要**删除**记录，只需要将记录从桶中删除即可。如果这个桶有溢出链，还要查看一下溢出链中是否也有相同记录。

   而**修改**记录会稍微麻烦些。如果要修改的字段不是散列字段，那直接修改即可，但如果修改的是散列字段，那意味着记录可能需要移到其他桶中，所以需要先删除就记录，再插入修改后的记录。

   由于这种散列法事先指定了桶的个数，所以通常称为**静态散列**。对于动态文件来说，这是一个很大的缺陷。假设有M个桶，每个桶最多存放m条记录，当记录个数远小于(M*m)时，将造成极大浪费，反之，又将引发大量冲突，而且随着**溢出链表**变长，检索速度将明显下降。虽然通过周期性重组可以缓解问题，但对于大型文件而言，重组的代价将极大！

5. **动态散列**：动态散列又具体分为：**可扩展散列**和**线性散列**两种。

6. **可扩展散列**利用了这样一个事实：应用散列函数后得到的结果是一个非负整数。因此可以表示为一个二进制数。存取结构建立在散列函数结果的二进制表示，即位串的基础上。

7. **线性散列**

8. s




### Chapter14 文件的索引结构

#### 单级有序索引的类型

1. 索引存取结构通常定义在该文件的单个字段上，这个字段称为**索引字段**。索引存储了该索引字段的每个值和一个指针列表，指针列表中的这些指针指向所有包含该字段值的记录的磁盘块。索引中的值是有序的，因此查找效率很快。

   有序索引分几种类型：**主索引**、**聚簇索引**、**辅助索引**。

2. + **主索引**建立在有序记录文件的排序码字段上，它本身是一个有序文件，文件中的每个记录包含两个字段的定长记录，第一个字段与数据文件的排序码字段有相同的数据类型，第二个字段是指向一个磁盘块的指针。所以，对于数据文件中的每一块，都会对应索引文件中的一个索引项。这个索引项的第一个字段是数据块第一个记录的主码字段值，第二个字段是该数据块的地址。
   + 索引分为**稠密索引**和**稀疏索引**。所谓**稠密索引**，是指数据文件中的每条记录都会对应一个索引项，而**稀疏索引**则只是对于某些搜索值有索引项。显然，**主索引**是**稀疏索引**。
   + 使用主索引检索数据的时候，只需要在索引文件上进行一次二分查找（由于索引文件比原文件会小的多，所以I/O的开销更小），然后再根据找到的索引到原文件指定的数据块中读取磁盘块就能找到数据了（注意索引的字段在原文件是唯一且有序的）。
   + 使用主索引后，对文件的插入操作将变得更加复杂。除了在原文件上插入数据的开销外，还要维护索引文件（因为插入新的记录后，可能导致某些数据块的第一条记录发生改变）。

3. + **聚簇索引**：如果文件的记录以一个非码字段进行**物理排序**，那么这个字段被称为聚簇字段。之所以称聚簇，是因为非码字段的值可能并不唯一。基于聚簇字段，可以构建**聚簇索引**。
   + **聚簇索引**的索引项包含两个字段，第一个字段的值与聚簇字段的值相同，第二个字段代表的是聚簇字段的磁盘块指针（由于聚簇字段可能包括多个，所以只需要指向第一个磁盘块，注意原文件是根据聚簇字段排好序的）。
   + 同样，插入操作对**聚簇索引**会产生很大的影响。

4. + **辅助索引**提供了访问文件中除了已有的主访问方法之外的一种辅助方法。对于前两种索引，如果索引字段没有排序，那索引就没法发挥作用，而辅助索引就是针对这些没有排序的字段准备的。
   + **辅助索引**的索引项包含两个字段，第一个字段的值与索引字段相同，第二个字段是该索引字段的块指针或记录指针。由于辅助索引的字段通常都是非排序字段，所以辅助索引常常是一个稠密索引。尽管如此，使用辅助索引比直接在原文件上进行线性查找依然快上很多。

5. 总结：

    ![屏幕快照 2016-09-14 上午12.06.36](/Users/xyz/GitCode/jermmy.github.io/source/images/2016-9-11/屏幕快照 2016-09-14 上午12.06.36.png)

#### 多级索引

简单理解下概念，就是在索引文件的基础上继续建立索引文件，进一步加快查询速度。

#### 使用B树与B+树的动态多级索引



#### 多码上的索引








